# DM-scorer 项目框架梳理

## 一、项目概述

这是一个基于**八叉树卷积神经网络（Octree-based Sparse CNN）**的**3D模型姿态评分系统**，主要用于评估铣削加工中的刀具姿态优劣。项目通过深度学习模型预测工件在特定刀具参数下的最优加工姿态（pitch和roll角度），并对不同姿态进行打分。

### 核心技术栈
- **深度学习框架**: PyTorch
- **3D数据结构**: Octree（八叉树）稀疏表示
- **模型架构**: U-Net 变体（支持编码器/解码器多种配置）
- **任务类型**: 姿态回归 + 打分表学习

---

## 二、目录结构

```
DM-scorer/
├── projects/                          # 核心项目代码
│   ├── segmentation.py                # 主训练器（SegSolver），定义loss、metrics等
│   ├── run_seg_deepmill.py            # 启动脚本，配置训练参数和超参数
│   ├── configs/
│   │   └── seg_deepmill.yaml          # 训练配置文件（模型、数据、优化器等）
│   │
│   ├── data_2.0/                      # 数据集目录
│   │   ├── filelist/
│   │   │   ├── models_train_val.txt   # 训练集文件列表
│   │   │   └── models_test.txt        # 测试集文件列表
│   │   └── points/                    # 点云数据（.ply文件）
│   │       └── models/
│   │
│   ├── datasets/                      # 数据加载模块
│   │   ├── __init__.py
│   │   ├── seg_shapenet.py            # ShapeNet数据集加载器
│   │   └── utils.py                   # 数据预处理工具（ReadPly, Transform）
│   │
│   ├── ocnn/                          # 八叉树卷积神经网络核心库
│   │   ├── models/                    # 模型定义
│   │   │   ├── unet.py                # U-Net模型（支持编码器/解码器模式）
│   │   │   ├── segnet.py              # SegNet模型
│   │   │   └── ...
│   │   ├── nn/                        # 八叉树神经网络层
│   │   │   ├── octree_conv.py         # 八叉树卷积
│   │   │   ├── octree_pool.py         # 八叉树池化
│   │   │   └── ...
│   │   ├── octree/                    # 八叉树数据结构
│   │   │   ├── octree.py              # Octree类
│   │   │   └── points.py              # Points类
│   │   └── modules/                   # 通用模块
│   │       └── modules.py             # 基础模块封装
│   │
│   ├── thsolver/                      # 训练框架
│   │   ├── solver.py                  # 通用Solver基类（训练循环、优化器、调度器）
│   │   ├── dataset.py                 # Dataset基类（支持打分表、刀具参数加载）
│   │   ├── config.py                  # 配置解析
│   │   ├── tracker.py                 # 指标追踪器
│   │   ├── lr_scheduler.py            # 学习率调度器
│   │   └── sampler.py                 # 数据采样器
│   │
│   ├── tools/                         # 工具脚本
│   │   ├── seg_deepmill_cutter.py     # 数据处理工具
│   │   └── utils.py
│   │
│   ├── logs/                          # 训练日志
│   │   └── seg_deepmill/
│   │       └── unet_d5/
│   │           └── models_models/
│   │               └── ratio_1.00/
│   │                   ├── checkpoints/      # 模型检查点
│   │                   ├── all_configs.yaml  # 完整配置
│   │                   └── events.out.tfevents.*  # TensorBoard日志
│   │
│   ├── rotation_matrices.json         # 预定义的338个旋转矩阵（用于离散化评分）
│   └── ultimate_rotation_map.json     # 终极旋转映射表
│
├── ad_test/                           # 测试脚本
│   ├── rotate_test.py
│   └── sixd_to_rotmat_batch.py
│
├── img/                               # 图片资源
├── test.py                            # 测试脚本
└── no_tool_log.txt                    # 日志文件

```

---

## 三、核心模块详解

### 3.1 训练主流程 (`segmentation.py` - `SegSolver`)

**继承关系**: `SegSolver` → `Solver` (thsolver/solver.py)

**核心职责**:
1. **模型构建**: 根据配置文件选择 UNet/SegNet 等模型
2. **数据处理**: 将点云转换为八叉树结构
3. **前向传播**: 
   - 输入: 八叉树特征 + 刀具参数（4维）
   - 输出: 2维角度 (pitch, roll) 或 6维表示
4. **损失函数**:
   - `loss_function`: Frobenius范数损失（旋转矩阵直接比较）
   - `loss_function_pro`: 软分配损失（与338个预定义矩阵比较）
   - `loss_function_promax`: 带z轴旋转不变性的损失
5. **评估指标**:
   - `mean/max/std_score`: 角度误差统计
   - `model_score`: 最近邻旋转矩阵的打分
   - `model_score_pro`: 带z轴旋转搜索的打分

**关键方法**:
```python
def model_forward(self, batch):
    # 1. 提取八叉树特征
    data = self.get_input_feature(octree)
    
    # 2. 模型预测（输入：八叉树特征 + 刀具参数）
    logit = self.model.forward(data, octree, depth, query_pts, tool_params)
    # logit: (B, 2) - [pitch, roll] in degrees
    
    return logit, labels
```

---

### 3.2 数据管道 (`thsolver/dataset.py` + `datasets/seg_shapenet.py`)

#### Dataset类 (`thsolver/dataset.py`)
- **功能**: 通用数据集基类
- **加载内容**:
  - 点云文件（.ply格式）
  - 打分表（338维向量，从 `/home/xinguanze/project/ex_4_dataset_making/result` 读取）
  - 刀具参数（4维向量）
  - 预定义旋转矩阵（338个）

**关键方法**:
```python
def __getitem__(self, idx):
    # 1. 读取点云
    sample = self.read_file(os.path.join(self.root, self.filenames[idx]))
    
    # 2. 数据增强和octree构建
    output = self.transform(sample, idx)
    
    # 3. 添加标签（338维打分表）
    output['labels'] = read_six_dim_vector(model_name)  # min-max归一化
    
    # 4. 添加刀具参数（4维）
    output['tool_params'] = self.tool_params[idx]
    
    return output
```

#### ShapeNetTransform (`datasets/seg_shapenet.py`)
- **功能**: 点云预处理
- **流程**:
  1. 读取点云坐标、法线
  2. 转换为 `Points` 对象
  3. 可选归一化（代码中已注释）

---

### 3.3 模型架构 (`ocnn/models/unet.py`)

#### UNet 配置化设计

**两种模式**:

##### Mode 1: 完整编码器-解码器 (use_decoder=True)
```
输入点云 → Octree
    ↓
Encoder (下采样 + ResBlocks)
    ├─ depth 5 (最深层)
    ├─ depth 4
    ├─ depth 3
    └─ depth 2
    ↓
Decoder (上采样 + Skip连接 + 刀具融合)
    ├─ depth 3 ← [上采样 + skip + tool_features_1]
    ├─ depth 4 ← [上采样 + skip + tool_features_2]
    ├─ depth 5 ← [上采样 + skip + tool_features_3]
    └─ depth 6 ← [上采样 + skip + tool_features_4]
    ↓
Octree Interpolation (插值到原始点)
    ↓
Global Average Pooling
    ↓
MLP Head → (pitch, roll)
```

**刀具参数融合方式**:
- 每个解码器阶段独立的 FC 网络：`4 → 32 → 256`
- 通过 concat 方式融合到特征图

##### Mode 2: 仅编码器 (use_decoder=False)
```
输入点云 → Octree
    ↓
Encoder (下采样 + ResBlocks)
    ├─ depth 5
    ├─ depth 4
    └─ depth 3
    ↓
Pyramid Pooling (多尺度特征聚合)
    ├─ 从指定层提取特征（pyramid_depths）
    └─ 池化到全局特征
    ↓
刀具参数融合 (concat/FiLM/no_tool)
    ↓
MLP Head → (pitch, roll)
```

**刀具融合策略**:
- `concat`: 直接拼接刀具嵌入向量（默认）
- `film`: FiLM调制（Feature-wise Linear Modulation）
- `no_tool`: 不使用刀具参数

**输出处理**:
```python
# 可选 Tanh 激活
if use_tanh_head:
    output = torch.tanh(output)
    pitch = output[:, 0] * 90.0   # [-90, 90]
    roll = output[:, 1] * 180.0   # [-180, 180]
```

---

### 3.4 八叉树结构 (`ocnn/octree/`)

#### 为什么使用八叉树？
传统3D卷积的问题:
- **内存开销大**: `N³` 体素网格
- **计算冗余**: 大量空体素无效计算

八叉树优势:
- **稀疏表示**: 只存储有点云的区域
- **自适应分辨率**: 根据深度动态划分
- **高效计算**: 专门设计的卷积/池化算子

#### Octree 构建流程
```python
octree = ocnn.octree.Octree(depth=5, full_depth=2)
octree.build_octree(points)  # points: (N, 3)
octree.construct_all_neigh()  # 构建邻域信息

# depth=5: 最大深度，2^5 = 32 × 32 × 32 分辨率
# full_depth=2: 前2层全填充
```

---

### 3.5 训练框架 (`thsolver/solver.py`)

#### Solver 基类功能
- **多GPU支持**: 分布式数据并行（DDP）
- **自动混合精度**: AMP加速训练
- **学习率调度**: 阶梯式/余弦退火
- **检查点管理**: 自动保存最优模型
- **TensorBoard日志**: 实时可视化

**训练循环**:
```python
def train_epoch(self):
    for batch in self.train_loader:
        # 1. 前向传播
        output = self.train_step(batch)  # 子类实现
        
        # 2. 反向传播
        loss = output['train/loss']
        loss.backward()
        
        # 3. 参数更新
        self.optimizer.step()
        self.optimizer.zero_grad()
        
        # 4. 指标记录
        self.log_metrics(output)
```

---

## 四、配置文件详解 (`configs/seg_deepmill.yaml`)

```yaml
SOLVER:
  run: train                      # 运行模式: train/test/eval
  gpu: (1,)                       # GPU设备ID
  type: sgd                       # 优化器类型
  best_val: min:test/model_score  # 最优模型选择指标
  max_epoch: 300                  # 最大训练轮数
  test_every_epoch: 10            # 测试频率
  milestones: (120,180,240)       # 学习率衰减里程碑

DATA:
  train:
    name: shapenet
    depth: 5                      # 八叉树深度
    full_depth: 2                 # 全填充深度
    batch_size: 8
    
    # 数据增强
    distort: True
    angle: (0, 5, 0)              # 旋转角度范围
    scale: 0.25                   # 缩放范围
    jitter: 0.25                  # 抖动强度
    
    location: data_2.0/points
    filelist: data_2.0/filelist/models_train_val.txt

  test:
    name: shapenet
    depth: 5
    batch_size: 1
    location: data_2.0/points
    filelist: data_2.0/filelist/models_test.txt

MODEL:
  name: unet
  feature: ND                     # 特征类型（Normal + Depth）
  channel: 4                      # 初始通道数
  nout: 6                         # 输出维度（6D表示或2角度）
  
  # 编码器-only配置
  use_decoder: false              # 是否使用解码器
  pyramid_levels: (0)             # 金字塔池化层级
  tool_fusion: 'concat'           # 刀具融合方式
  use_attention_pool: false       # 是否使用注意力池化
  use_tanh_head: true             # 是否使用Tanh输出

LOSS:
  num_class: 2                    # 兼容旧代码保留
```

---

## 五、数据格式

### 5.1 输入数据

#### 点云文件 (.ply)
- **格式**: PLY (Polygon File Format)
- **内容**: 点坐标 + 法线 + 标签（可选）
- **路径**: `data_2.0/points/models/*.ply`

#### 文件列表 (.txt)
```
# 格式: <相对路径> <类别ID> <tool_param1> <tool_param2> <tool_param3> <tool_param4>
models/00181080_1b7d16dab26af7058f098574_trimesh_000_collision_detection.ply 0 3.0 5.0 2.0 1.5
```

#### 打分表 (.txt)
- **路径**: `/home/xinguanze/project/ex_4_dataset_making/result/<model_id>.txt`
- **格式**: 338行浮点数（每行对应一个预定义姿态的打分）
- **处理**: min-max归一化到[0,1]

### 5.2 输出数据

#### 训练输出
- **检查点**: `logs/.../checkpoints/model_*.pth`
- **日志**: `logs/.../log.csv`
- **TensorBoard**: `logs/.../events.out.tfevents.*`

#### 评估输出
- **预测结果**: `logs/.../<filename>.eval.npz`
  - `angles_deg`: (2,) - [pitch, roll] in degrees
  - `R`: (3, 3) - 旋转矩阵

---

## 六、关键算法

### 6.1 旋转矩阵表示转换

#### 角度 → 旋转矩阵 (Rx @ Ry)
```python
def _angles_to_rotation_matrix(angles):
    pitch = angles[:, 0] * (π / 180)  # 小角度
    roll = angles[:, 1] * (π / 180)   # 大角度
    
    # Rx(roll) - 绕x轴
    Rx = [[1,    0,      0   ],
          [0, cos(r), -sin(r)],
          [0, sin(r),  cos(r)]]
    
    # Ry(pitch) - 绕y轴  
    Ry = [[ cos(p), 0, sin(p)],
          [   0,    1,   0   ],
          [-sin(p), 0, cos(p)]]
    
    return Rx @ Ry
```

#### 6D表示 → 旋转矩阵 (Gram-Schmidt)
```python
def _six_dim_to_rotation_matrix(six_dim):
    x, y = six_dim[:, :3], six_dim[:, 3:]
    
    x = x / ||x||                    # 归一化第一列
    y = y - (y·x)x                   # 正交化
    y = y / ||y||                    # 归一化第二列
    z = x × y                        # 叉乘得第三列
    
    return [x, y, z]  # (3, 3)
```

### 6.2 损失函数

#### loss_function_pro（软分配打分表）
```python
def loss_function_pro(logit, label):
    # 1. 预测角度 → 旋转矩阵
    R_pred = angles_to_rotation_matrix(logit)  # (B, 3, 3)
    
    # 2. 计算与338个预定义矩阵的测地距离
    R_diff = R_pred^T @ R_predefined           # (B, 338, 3, 3)
    trace = tr(R_diff)                         # (B, 338)
    geodesic_dist = arccos((trace - 1) / 2)    # (B, 338)
    
    # 3. 软分配（温度参数 τ=0.1）
    weights = softmax(-geodesic_dist / τ)      # (B, 338)
    
    # 4. 加权平均打分（label: 打分表，越小越好）
    loss = Σ(weights * label)                  # (B,) → scalar
    
    return loss.mean()
```

#### loss_function_promax（z轴旋转不变性）
额外步骤：
1. 生成12个z轴旋转（每30°）
2. 对每个预定义矩阵找最近的旋转变体
3. 其余同 `loss_function_pro`

### 6.3 评估指标

#### model_score_pro
```python
def model_score_pro(logit, score):
    # 1. 预测 → 旋转矩阵
    R_pred = angles_to_rotation_matrix(logit)
    
    # 2. z轴旋转搜索（12个候选）
    R_rotated = R_pred @ R_z[i]  # i=0..11
    
    # 3. 找最近的预定义矩阵
    distances = geodesic_distance(R_rotated, R_predefined)
    closest_idx = argmin(distances.min(dim=1))  # (B,)
    
    # 4. 返回对应打分
    return score[closest_idx].mean()
```

---

## 七、启动流程

### 7.1 训练命令
```bash
cd /home/xinguanze/project/ex_6_scorer/DM-scorer/projects

# 基础训练（完整数据）
python run_seg_deepmill.py \
    --alias unet_d5 \
    --gpu 0 \
    --depth 5 \
    --model unet \
    --ratios 1.0

# 编码器-only训练
python run_seg_deepmill.py \
    --alias unet_encoder_only \
    --gpu 0 \
    --encoder_only

# 从检查点恢复
python run_seg_deepmill.py \
    --ckpt logs/seg_deepmill/unet_d5/.../checkpoints/model_best.pth
```

### 7.2 配置优先级
```
命令行参数 > run_seg_deepmill.py硬编码 > seg_deepmill.yaml
```

例如:
```python
# run_seg_deepmill.py 会覆盖 YAML 中的:
'MODEL.nout': '6'              # 强制6D输出
'SOLVER.best_val': 'min:loss'  # 最优模型指标
```

---

## 八、关键设计亮点

### 8.1 刀具参数感知
- **动机**: 不同刀具（直径、长度等）需要不同的加工姿态
- **实现**: 
  - 解码器模式: 每层独立FC融合
  - 编码器模式: 全局嵌入后concat/FiLM

### 8.2 打分表学习
- **传统方法**: 直接回归角度（需要GT角度标注）
- **本项目**: 学习338个离散姿态的优劣排序
  - 优势: 标注成本低（只需物理仿真打分）
  - 挑战: 软分配+温度参数调优

### 8.3 z轴旋转不变性
- **背景**: 铣削加工中，绕刀具轴线旋转不影响加工效果
- **promax损失**: 显式搜索12个z轴旋转，取最优匹配
- **效果**: 更符合物理约束，提升泛化能力

### 8.4 八叉树高效表示
- **内存对比**:
  - 传统体素 (128³): ~2M cells
  - 八叉树 (depth=7): ~10K nodes (200× reduction)
- **性能**: 专门优化的CUDA kernel（octree_conv等）

---

## 九、常见问题与解决方案

### 9.1 loss为NaN
**原因**:
- 旋转矩阵计算中出现数值不稳定
- arccos输入超出[-1,1]范围

**解决**:
```python
cos_angle = torch.clamp((trace - 1) / 2, -0.999999, 0.999999)
distances = torch.where(torch.isnan(distances), 
                       torch.zeros_like(distances), 
                       distances)
```

### 9.2 打分表读取失败
**检查**:
1. 文件路径是否正确（`/home/xinguanze/project/ex_4_dataset_making/result`）
2. 文件名格式: `<model_id>.txt`（不含 `_collision_detection`）
3. 文件行数是否为338行

### 9.3 内存溢出
**优化**:
- 降低 `batch_size`（默认8）
- 减小 `octree depth`（默认5）
- 使用 `gradient_checkpointing`（需修改模型）

### 9.4 训练速度慢
**加速**:
- 开启 `pin_memory=True`（已默认）
- 增加 `num_workers`（YAML中注释了，可取消）
- 使用混合精度训练（Solver已支持，需开启）

---

## 十、扩展方向

### 10.1 模型改进
- [ ] Transformer注意力机制（替换卷积）
- [ ] 多尺度特征融合优化
- [ ] 动态刀具嵌入网络

### 10.2 数据增强
- [ ] PointNet++风格采样
- [ ] MixUp/CutMix适配点云
- [ ] 对抗样本生成

### 10.3 损失函数
- [ ] 对比学习损失（同模型相似姿态拉近）
- [ ] 分层损失（粗细粒度结合）
- [ ] 物理约束正则化

### 10.4 部署优化
- [ ] ONNX导出（需适配octree算子）
- [ ] TensorRT加速
- [ ] 量化（INT8推理）

---

## 十一、参考资料

### 代码库
- **O-CNN**: [octree-based convolutional neural networks](https://github.com/microsoft/O-CNN)
- **原论文**: Wang et al., "O-CNN: Octree-based Convolutional Neural Networks", TOG 2017

### 相关技术
- **6D旋转表示**: Zhou et al., "On the Continuity of Rotation Representations", CVPR 2019
- **FiLM调制**: Perez et al., "FiLM: Visual Reasoning with a General Conditioning Layer", AAAI 2018
- **测地距离**: Huynh, "Metrics for 3D Rotations", J. Math Imaging Vis 2009

---

## 附录：快速上手

### A.1 环境配置
```bash
# 安装依赖（推荐使用conda）
pip install torch torchvision
pip install ocnn  # 八叉树库
pip install tqdm pyyaml tensorboard

# 验证CUDA
python -c "import torch; print(torch.cuda.is_available())"
```

### A.2 数据准备
```bash
# 确保数据路径存在
ls data_2.0/points/models/  # 点云文件
ls data_2.0/filelist/       # 文件列表
ls /home/xinguanze/project/ex_4_dataset_making/result/  # 打分表
```

### A.3 快速训练
```bash
cd projects
python run_seg_deepmill.py --gpu 0 --ratios 0.1  # 10%数据快速测试
```

### A.4 监控训练
```bash
# TensorBoard
tensorboard --logdir=logs/seg_deepmill/unet_d5

# 实时查看log
tail -f logs/seg_deepmill/unet_d5/models_models/ratio_1.00/log.csv
```

---

**文档版本**: v1.0  
**更新日期**: 2025-11-06  
**维护者**: xinguanze

